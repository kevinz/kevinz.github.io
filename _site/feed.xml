<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术学习日志</title>
    <description>就是看下能坚持写多久，已经过了吹牛的年纪
</description>
    <link>http://gekben.gitcd.com//</link>
    <atom:link href="http://gekben.gitcd.com//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 18 Feb 2016 22:21:06 +0800</pubDate>
    <lastBuildDate>Thu, 18 Feb 2016 22:21:06 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Tom&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Thu, 18 Feb 2016 20:31:30 +0800</pubDate>
        <link>http://gekben.gitcd.com//jekyll/update/2016/02/18/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//jekyll/update/2016/02/18/welcome-to-jekyll.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Kernel dynamic debugging and taints</title>
        <description>&lt;p&gt;最近在为自己写的LKM添加调试功能时，发现了一个比printk更好的选择，就是&lt;a href=&quot;http://lwn.net/Articles/434833/&quot;&gt;dynamic debugging&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
list all dynamic_debug enabled items
#mkdir /debug
#mount -t debugfs debugfs /debug
// 看下哪些地方使用了dynamic_debug机制
#cat /debug/dynamic_debug/control
#echo &#39; +p&#39; &amp;gt; /sys/kernel/debug/dynamic_debug/control
&lt;/code&gt;
这样就能打开所有的dynmaic_debug items，对于Linux kernel source tree里的代码，dynamic_debug是适用的，但自己写的LKM似乎用不了这个机制，于是花了些时间想一探究竟。&lt;/p&gt;

&lt;p&gt;来看下pr_debug或者dev_dbg的定义:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;linux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* If you are writing a driver, please use dev_dbg instead */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#if defined(DEBUG)
#define pr_debug(fmt, ...) \
        printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
#elif defined(CONFIG_DYNAMIC_DEBUG)
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* dynamic_pr_debug() uses pr_fmt() internally so we don&#39;t need it here */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define pr_debug(fmt, ...) \
        dynamic_pr_debug(fmt, ##__VA_ARGS__)
#else
#define pr_debug(fmt, ...) \
        no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
#end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;可见&lt;code class=&quot;highlighter-rouge&quot;&gt;CONFIG_DYNAMIC_DEBUG&lt;/code&gt;是必须开的,&lt;code class=&quot;highlighter-rouge&quot;&gt;zcat /proc/config.gz|grep -i dynamic_debug&lt;/code&gt;可查。&lt;/p&gt;

&lt;p&gt;做了调试后发现，关键是在加载LKM时被识别为对kernel有taint的模块。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;linux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check_module_license_and_versions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 只对安全的LKM开启dynamic_debug
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taints&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taints&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TAINT_CRAP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dynamic_debug_setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;写了个最简单的LKM，license是GPL，加载时还是有问题，不知道是不是必须编译进Kernel才可以，等做了实验再更新一下。&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Mar 2013 09:41:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//linux/kernel/debug/2013/03/19/kernel-dynamic-debugging.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//linux/kernel/debug/2013/03/19/kernel-dynamic-debugging.html</guid>
        
        
        <category>linux</category>
        
        <category>kernel</category>
        
        <category>debug</category>
        
      </item>
    
      <item>
        <title>火星包: rp_filter and martian packet</title>
        <description>&lt;p&gt;经常在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/messages&lt;/code&gt;里发现这种消息，它是对流入的包进行路由检查失败后，发出的警告。
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
martian source 192.168.1.1 from 10.0.0.1, on dev eth1
ll header: 52:54:00:98:99:d0:52:54:00:de:d8:10:08:00 
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;代码出处在此
&lt;code class=&quot;highlighter-rouge&quot;&gt;c
kernel_source/net/ipv4/route.c 
static void ip_handle_martian_source(struct net_device *dev,
				     struct in_device *in_dev,
				     struct sk_buff *skb,
				     __be32 daddr,
				     __be32 saddr)
{
	RT_CACHE_STAT_INC(in_martian_src);
#ifdef CONFIG_IP_ROUTE_VERBOSE
	if (IN_DEV_LOG_MARTIANS(in_dev) &amp;amp;&amp;amp; net_ratelimit()) {
		/*
		 *	RFC1812 recommendation, if source is martian,
		 *	the only hint is MAC header.
		 */
		printk(KERN_WARNING &quot;martian source %pI4 from %pI4, on dev %s\n&quot;,
			&amp;amp;daddr, &amp;amp;saddr, dev-&amp;gt;name);
		if (dev-&amp;gt;hard_header_len &amp;amp;&amp;amp; skb_mac_header_was_set(skb)) {
			int i;
			const unsigned char *p = skb_mac_header(skb);
			printk(KERN_WARNING &quot;ll header: &quot;);
			for (i = 0; i &amp;lt; dev-&amp;gt;hard_header_len; i++, p++) {
				printk(&quot;%02x&quot;, *p);
				if (i &amp;lt; (dev-&amp;gt;hard_header_len - 1))
					printk(&quot;:&quot;);
			}
			printk(&quot;\n&quot;);
		}
	}
#endif
}
&lt;/code&gt;
&lt;!-- more --&gt;
其中，10.0.0.1表示src ip,192.168.0.1表示dst ip,eth1表示实际收包的设备，来看看为什么会有错误。&lt;/p&gt;

&lt;p&gt;```c
kernel_source/net/ipv4/fib_frontend.c
int fib_validate_source(){
    // 代码有选择性省略
    // 反转src和dst
	struct flowi fl = { .nl_u = { .ip4_u =
				      { .daddr = src,
					.saddr = dst,
					.tos = tos } },
			    .mark = mark,
			    .iif = oif };&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;in_dev = __in_dev_get_rcu(dev);
// 拿到收包的设备，顺便取出该设备上rp_filter的flag
if (in_dev) {
	no_addr = in_dev-&amp;gt;ifa_list == NULL;
	rpf = IN_DEV_RPFILTER(in_dev);
	if (mark &amp;amp;&amp;amp; !IN_DEV_SRC_VMARK(in_dev))
		fl.mark = 0;
}
rcu_read_unlock();

if (in_dev == NULL)
	goto e_inval;
net = dev_net(dev);
// 以src为dst，查fib
if (fib_lookup(net, &amp;amp;fl, &amp;amp;res))
	goto last_resort;
if (res.type != RTN_UNICAST)
	goto e_inval_res;
*spec_dst = FIB_RES_PREFSRC(res);
fib_combine_itag(itag, &amp;amp;res);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;ifdef-configiproutemultipath&quot;&gt;ifdef CONFIG_IP_ROUTE_MULTIPATH&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 以src作为dst，查到的发送dev和当前收包的dev相同，一切ok
if (FIB_RES_DEV(res) == dev || res.fi-&amp;gt;fib_nhs &amp;gt; 1) #else
if (FIB_RES_DEV(res) == dev) #endif
{
	ret = FIB_RES_NH(res).nh_scope &amp;gt;= RT_SCOPE_HOST;
	fib_res_put(&amp;amp;res);
	return ret;
}
fib_res_put(&amp;amp;res);
if (no_addr)
	goto last_resort;
// 如果dev不相同，并且rp_filter置为on，则检查失败
if (rpf == 1)
	goto e_inval;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;}
&lt;code class=&quot;highlighter-rouge&quot;&gt;
给一些的配置
&lt;/code&gt;bash
sysctl.conf
// 0 means off,1 means on
net.ipv4.conf.all.rp_filter = 0
net.ipv4.conf.default.rp_filter = 0
net.ipv4.conf.eth0.rp_filter = 0
net.ipv4.conf.lo.rp_filter = 0
net.ipv4.conf.vboxnet0.rp_filter = 0
net.ipv4.conf.wlan0.rp_filter = 0
```
&lt;code class=&quot;highlighter-rouge&quot;&gt;net.ipv4.conf.all.rp_filter&lt;/code&gt;是总开关，一开全开。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
// 0 means off
net.ipv4.conf.all.log_martians = 0
net.ipv4.conf.default.log_martians = 0
net.ipv4.conf.eth0.log_martians = 0
net.ipv4.conf.lo.log_martians = 0
net.ipv4.conf.vboxnet0.log_martians = 0
net.ipv4.conf.wlan0.log_martians = 0
&lt;/code&gt;
是否记录martian的开关，对应于代码里的&lt;code class=&quot;highlighter-rouge&quot;&gt;IN_DEV_LOG_MARTIANS(in_dev)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;小结一下，这个错误提示是很常见的，以至于常常被忽略，大多数情况它是做了正确的事情，不过当发现有意外的丢包，可以想想是否是遭遇了火星包，排查方法是：先做tcpdump，发现有traffic(tcpdump不受火星包的影响)，但kernel hook或者app收不到包，应怀疑是martian source导致丢包，用dmesg看下是否有相关提示。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
martian source 192.168.1.1 from 10.0.0.1, on dev eth1
ll header: 52:54:00:98:99:d0:52:54:00:de:d8:10:08:00 
&lt;/code&gt;
做一下翻译:eth1上收到了src=10.0.0.1,dst=192.168.1.1的包，但是按照本机的路由设置对10.0.0.1进行路由计算，得出的out dev不是eth1。
一般遇到这种还是保持rp_filter=1吧，毕竟这个开关能让系统免受很多火星来客的干扰，研究下路由配置应该能解决问题；如果确实很复杂的使用场景，比如这台server有好多个网口，需要在不同网口之间转发，放开rp_filter的限制也无妨。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Mar 2013 22:53:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//linux%20kernel/2013/03/18/rp-filter-and-martian-packet.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//linux%20kernel/2013/03/18/rp-filter-and-martian-packet.html</guid>
        
        
        <category>linux kernel</category>
        
      </item>
    
      <item>
        <title>基于lvs的全透明传输思考</title>
        <description>&lt;p&gt;互联网公司一般使用LB的方式，是把Web App Server作为real server，最简单的情况是请求在这里终结，响应由Web App Server返回，一般web server不用再访问外网了。再复杂的情况，就
是Web App Server又作为client去请求内网的其它资源，如DB，其它Web Server等，在这种典型的互联网部署模式下，一般可以把Web Server看作终点。&lt;/p&gt;

&lt;p&gt;还有一种部署方式，load balancing的对象不是Web App Server，而是firewall系统，比如用linux搭建的firewall，经过firewall的流量需要全透明传输，即不修改layer 2以上的信息，firewall
对过滤后合格的包做forwarding。在这种部署模式下，LB也需要有全透明传输的能力，画个图解释一下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;imgpopup /images/post_img/lvs_trans_firewall.png&quot; alt=&quot;&quot; /&gt;
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;这里所说的LB都是lvs，以http为例，首先client请求WWW Server，client有自己的公网地址，组装好的ip header，source ip是cip，destination ip是www_ip，
source port是cport，destination port 80，lvs要支持这种destination ip非vip的部署，需要使用到fwmark。
首先是要mark出这个请求：
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
mark the traffic 
#iptables -t mangle -A PREROUTING -p tcp --dport 80 -j MARK --set-xmark 1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后交由lvs处理：
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
direct traffic to local_in hook
#ip rule add prio 101 fwmark 1 table 101
#ip route add local 0/0 dev lo table 10
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;lvs的fwmark service及real server：
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
lvs fwmark service and real servers hook
#ipvsadm -A -f 1 -p #default scheduler is wlc,enable persistent
#ipvsadm -a -f 1 -r rs1 #default xmit method is direct routing 
#ipvsadm -a -f 1 -r rs2
#ipvsadm -a -f 1 -r rs2
#ipvsadm -a -f 1 -r rs2
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样配置后，LB1充当了透明的load balancer，经过LB1的request的layer2以上的信息都没有变化，rs1~rs4都可以接收请求，
并进行过滤处理，也是全透明的。先考虑没有LB2的情况，request从rs出来，被转发到Router，Router在将request转发至外网，
直至WWW_Server。从Client到WWW_server，layer2以上的地址和端口信息都没有改变。&lt;/p&gt;

&lt;p&gt;Response从WWW_Server出发，source是www_ip：80，destination是cip:cport，发向Router，Router这时候不知道该
如何进行路由了，因为从rs1出来的request，对应的response也要回到rs1，Router没有rs1的内部ip，也没有连接信息
参考，response回不到对应real server，连接无法建立起来。&lt;/p&gt;

&lt;p&gt;产生这个问题的原因是real server是有状态的，在request经过它时做了记录，例如linux的防火墙的基础conn_track，它期待response
也必须经过这台real server，tcp/udp以及基于它们的应用层协议都是如此。为了让response能回到正确的real server，需要利用到一种技术，
所有request和response都要经过它转发，在request进来时，记录它的源mac地址和接收包的device，response回来时，绕过路由直接发送给
之前记录的源mac，维护连接表+mac地址是必须的。&lt;/p&gt;

&lt;p&gt;目前支持这种技术的设备有F5，被称为Auto Last Hop，还有Juniper的某些设备，称作Reverse Route。把这种设备部署在LB2的位置，即可实现
full transparent，当然，也不是一定要单独搞一台LB2，用一台LB既做Load Balancer又做反向路由也是可以的。使用这种设备的最大缺点就是，
贵。于是想基于Lvs实现方向路由功能，想想也是非常合理的，lvs本身可以很好的维护管理连接状态，它有一张connection table，连接状态迁移，
超时机制，垃圾回收都已经非常成熟，再加上source mac和in_dev并不难。需要注意的是，lvs在这种使用模式下，应该定义fwmark service，它的rs只有一个，
就是下一跳的ip。经过一段时间的开发，对lvs进行修改后，基于lvs的反向路由功能已经OK，准备下一篇来讲讲细节。&lt;/p&gt;

</description>
        <pubDate>Tue, 13 Nov 2012 17:28:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//linux/lvs/kernel/network/2012/11/13/full-transparent-with-lvs.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//linux/lvs/kernel/network/2012/11/13/full-transparent-with-lvs.html</guid>
        
        
        <category>linux</category>
        
        <category>lvs</category>
        
        <category>kernel</category>
        
        <category>network</category>
        
      </item>
    
      <item>
        <title>搭建基于User Mode Linux网络模块开发环境</title>
        <description>&lt;p&gt;最近在写一些内核网络模块，需要一个好用的编译、调试、测试环境，选用了uml，记录一下设置多台uml和host通信，并share fs。
uml基本安装和使用可以参考&lt;a href=&quot;https://wiki.archlinux.org/index.php/User-mode_Linux#Setup_by_rootfs_.2B_tap&quot;&gt;archlinux uml&lt;/a&gt;。
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
uml with vde support 
# 先启动虚拟switch
#vde_switch -s /tmp/switch1 -tap tap0 -m 666
# 启动一台单网卡的uml，已经与之前定义的switch绑定
#vmlinux ubd0=arch_rootfs1  mem=256M eth0=vde,/tmp/switch1
# 启动一台双网卡的uml，已经与之前定义的switch绑定
#vmlinux ubd0=arch_rootfs2  mem=256M eth0=vde,/tmp/switch1 eth1=vde,/tmp/switch1
&lt;/code&gt;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;启动完成后，在linux里用常规的网络设置方法完成ip地址的分配。
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
network configuration
#ifconfig eth0 192.168.0.101 up
#ifconfig eth1 192.168.0.101 up
#确定host上的tap0已经正确设置并启用
#ifconfig tap0 192.168.0.100 up
&lt;/code&gt;
完成后用ping测试下，各个uml和host之间的网络通信是否正常。&lt;/p&gt;

&lt;p&gt;接下来设置uml与主机的文件系统共享。
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
mounting hostfs directory
#mkdir -p /root/source
#mount none /root/source/ -t hostfs -o /home/yourname/code/
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;完成后，应该可以读写hostfs的文件，测试一下，放一份linux源代码在host的&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/yourname/code/&lt;/code&gt;下，
目录结构是&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/yourname/code/linux&lt;/code&gt;，自己写的module的目录在&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/yourname/code/my_module&lt;/code&gt;，
对应在uml上的目录就是&lt;code class=&quot;highlighter-rouge&quot;&gt;/root/source/linux&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/root/source/my_module&lt;/code&gt;。
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
Makefile of my_module
obj-m := test.o #source file is test.c
KDIR := /root/source/linux
PWD := $(shell pwd)
default:
        $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;/root/source/my_module&lt;/code&gt;下&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;就可以了，在&lt;code class=&quot;highlighter-rouge&quot;&gt;#insmod test.ko&lt;/code&gt;测试，如果crash了就&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;掉host上的&lt;code class=&quot;highlighter-rouge&quot;&gt;vmlinux&lt;/code&gt;进程，非常方便快速。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
kill all vmlinux process
#killall vmlinux processes if uml can&#39;t be started
#killall vmlinux
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然，gdb也是可以用的，可以参考uml gdb调试相关的介绍。&lt;/p&gt;

</description>
        <pubDate>Tue, 13 Nov 2012 15:40:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//linux/kernel/network/2012/11/13/build-uml-development-environment.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//linux/kernel/network/2012/11/13/build-uml-development-environment.html</guid>
        
        
        <category>linux</category>
        
        <category>kernel</category>
        
        <category>network</category>
        
      </item>
    
      <item>
        <title>在SUSE Enterprise上安装Systemtap，解决build-id mismatch</title>
        <description>&lt;p&gt;最近做LVS的性能测试，自然会用的各种工具检视系统状态，用了很多工具，都
不甚满意，于是想尝试下Systemtap，系统环境是SUSE Enterprise SP2,已经3.0的
kernel，可以search到的suse上安装systemtap的内容不多，碰到问题并解决了
的更是少，自然我又要成为苦逼的问题解决者了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;正常安装的步骤是&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;添加suse enterprise的包含debuginfo的iso，有几个G啊&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zypper in kernel-default-debuginfo&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zypper in systemtap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我做完了以上这些，运行一个简单的脚本时:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
systemtap hello_world 
sudo stap -ve &#39;probe begin { log(&quot;hello world&quot;) exit() }&#39;
&lt;/code&gt;
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;这个简单的例子是ok的，因为它不会涉及到systemtap的pass5，与kernel
module交互。跑下面这个的时候，就不行了:
&lt;code class=&quot;highlighter-rouge&quot;&gt;
systemtap hello_world 
stap -v -e &#39;probe vfs.read {printf(&quot;has VFS read()\n&quot;); exit()}&#39; 
&lt;/code&gt;
会报出类似&lt;code class=&quot;highlighter-rouge&quot;&gt;ERROR: Build-id mismatch: &quot;kernel&quot; vs. &quot;vmlinux&quot; byte 0 (0xf9 vs 0xa2)&lt;/code&gt;的问题，关于build-id mismatch这个问题，还是可以
搜索到不少资料的，不过告诉如何解决的也不多。先说明下这个问题，
&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel-default-debuginfo&lt;/code&gt;里面是附赠了一个kernel elf文件的，在SUSE里，
安装后放在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/debug/boot/vmlinux-3.0.13-0.27-default.debug&lt;/code&gt;，这
是debug版本的kernel vmlinux文件，是elf原始文件，未经压缩。&lt;code class=&quot;highlighter-rouge&quot;&gt;stap&lt;/code&gt;运行时会去检查它的。
执行&lt;code class=&quot;highlighter-rouge&quot;&gt;eu-readelf -n
/usr/lib/debug/boot/vmlinux-3.0.13-0.27-default.debug&lt;/code&gt;，可以拿到的
build-id，执行结果的第一个字节是&lt;code class=&quot;highlighter-rouge&quot;&gt;f9&lt;/code&gt;，那另外一个&lt;code class=&quot;highlighter-rouge&quot;&gt;a2&lt;/code&gt;是从哪里得出来的，猜想应该和当
前运行的kernel有关，于是拿到当前运行的vmlinux的压缩文件，解压后检查
build-id：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
check build-id 
   gunzip /boot/vmlinux-3.0.13-0.27-default.gz 
   eu-readelf -n /boot/vmlinux-3.0.13-0.27-default 
&lt;/code&gt;
执行结果也是&lt;code class=&quot;highlighter-rouge&quot;&gt;f9&lt;/code&gt;，是对得上的啊。&lt;/p&gt;

&lt;p&gt;但是注意，这份.gz文件是SUSE附赠的，跟当前跑的vmlinz文件没有关系，于是
开始打vmlinuz文件的主意，得先想办法把vmlinuz-&amp;gt;vmlinux，及bzImage到elf，
才能去取它的build-id，
&lt;a href=&quot;这里&quot;&gt;https://www.globalways.net/blog/archives/76-Extracting-bzImage-from-vmlinuz.html&lt;/a&gt;有可行的方法。
&lt;code class=&quot;highlighter-rouge&quot;&gt;eu-readelf -n vmlinux-unpacked&lt;/code&gt;的结果果然是&lt;code class=&quot;highlighter-rouge&quot;&gt;a2&lt;/code&gt;，我只能是怀疑SUSE给的
默认vmlinuz有问题了，不能和SUSE提供的用于debuginfo的vmlinux匹配。&lt;/p&gt;

&lt;p&gt;只能另外想办法，其实systemtap做kernel mismatch判断的关键代码，就在:&lt;/p&gt;

&lt;p&gt;```c
systemtap/runtime/sym.c
static int _stp_build_id_check (struct _stp_module &lt;em&gt;m,
            unsigned long notes_addr,
            struct task_struct *tsk)
{
…
/&lt;/em&gt; just hack it */
if (rc || (theory != practice)) {
      const char *basename;
      basename = strrchr(m-&amp;gt;path, ‘/’);
      if (basename)
|   basename++;
      else
|   basename = m-&amp;gt;path;&lt;/p&gt;

&lt;h1 id=&quot;if-linuxversioncode--kernelversion2627&quot;&gt;if LINUX_VERSION_CODE &amp;gt;= KERNEL_VERSION(2,6,27)&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  _stp_error (&quot;Build-id mismatch: \&quot;%s\&quot; vs. \&quot;%s\&quot; byte %d (0x%02x vs 0x%02x) address %#lx rc %d\n&quot;, |   |     m-&amp;gt;name, basename, j, theory, practice, notes_addr, rc);
  return 1; #else
  /* This branch is a surrogate for kernels affected by Fedora bug
   * #465873. */
  _stp_warn (KERN_WARNING |   |    &quot;Build-id mismatch: \&quot;%s\&quot; vs. \&quot;%s\&quot; byte %d (0x%02x vs 0x%02x) rc %d\n&quot;, |   |    m-&amp;gt;name, basename, j, theory, practice, rc); #endif
  break;
} /* end mismatch */ ```    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关键就在于&lt;code class=&quot;highlighter-rouge&quot;&gt;if (rc || (theory != practice))&lt;/code&gt;，小小修改的一下，写成:
&lt;code class=&quot;highlighter-rouge&quot;&gt;if (0 &amp;amp;&amp;amp; (rc || (theory != practice)))&lt;/code&gt;就OK了，绕过了检查。然后重新编
译systemtap，直接用的SUSE提供的老版本的源码，新的会有问题，注意还要用
到SUSE提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;libdwfl&lt;/code&gt;的source code，才能完成编译，编译时在
&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/src/packages/SOURCES/elfutils-0.152/libdwfl/linux-kernel-modules.c&lt;/code&gt;
文件上遇到了问题，稍作修改就可过关。尝试下新编译出来的&lt;code class=&quot;highlighter-rouge&quot;&gt;stap&lt;/code&gt;，完全OK，它是不知
道’build-id mismatch`为何物的，敢这样改也就是因为都是offical的东西，本
应该match得上，应该不会出什么大问题，实践中检验吧。&lt;/p&gt;

&lt;p&gt;Have fun.&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Aug 2012 20:49:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//linux/tools/kernel/2012/08/16/install-systemtap-on-suse.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//linux/tools/kernel/2012/08/16/install-systemtap-on-suse.html</guid>
        
        
        <category>linux</category>
        
        <category>tools</category>
        
        <category>kernel</category>
        
      </item>
    
      <item>
        <title>升级Netxen网卡驱动及firmware</title>
        <description>&lt;p&gt;在公司做lvs测试用机是HP DL580 G7，除了网卡，其它的配置都不错，网卡是板
载的netxen的1G卡，还有几张netxen的10G卡，观察&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/interrupts&lt;/code&gt;，每块
10G卡对应的中断都只有4个，而且没有识别成tx-0/rx-0的形式，不像支持
multiple queue，不禁使我对SUSE 11
Enterprise SP2的netxen驱动产生的怀疑。&lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt;也可以发现有抱怨driver和
firmware的比较旧，于是萌生了升级驱动的想法。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;netxen&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;nx3031&lt;/code&gt;search
了很久而不得，偶然通过&lt;code class=&quot;highlighter-rouge&quot;&gt;nx_nic&lt;/code&gt;找到了HP网卡的驱动
&lt;a href=&quot;下载地址&quot;&gt;http://h20000.www2.hp.com/bizsupport/TechSupport/SoftwareIndex.jsp?lang=en&amp;amp;cc=us&amp;amp;prodNameId=3913538&amp;amp;prodTypeId=329290&amp;amp;prodSeriesId=3913537&amp;amp;swLang=8&amp;amp;taskId=135&amp;amp;swEnvOID=4049&lt;/a&gt;，包括firmware的自动升级程序和网卡驱动。值得吐一把嘈的是，HP
网站上driver是老旧的，不支持稍新的内核，貌似只支持到2.6.20以前的，编译
时会报&lt;code class=&quot;highlighter-rouge&quot;&gt;net_dev struct&lt;/code&gt;相关的错，费了
那么大的力气，搞来个不能用的，之后还是google到了最新的驱动，在一个连域
名都没有的
&lt;a href=&quot;ftp&quot;&gt;ftp://15.217.49.75/ftp2/pub/softlib2/software1/pubsw-linux/p280489831/&lt;/a&gt;
上，haha，真欢乐，HP sucks.按照说明先升级好driver，&lt;code class=&quot;highlighter-rouge&quot;&gt;modprobe nx_nic&lt;/code&gt;后，
就可以升级firmware了，要注意的是，把每个网卡都up起来，才能保证所有都升
级成功，我拆掉了一些bond，保证以前是slave状态的卡都up起来之后，经过10
分钟左右，升级成功。重启后&lt;code class=&quot;highlighter-rouge&quot;&gt;dmesg&lt;/code&gt;里的complains少了很多，新版本也显示出
来了，还是没识别出multiple queue，编译驱动时也检查了选项，确实没有。同
事也咨询过HP的sales，也不知道多队列网卡为何物，与Intel的资料的专业性相比，我对
HP的网卡实在是无力吐嘈。之后研究下再驱动代码吧，有代码有真相。&lt;/p&gt;

&lt;p&gt;Have fun.&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Aug 2012 20:15:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//linux/network/2012/08/16/upgrade-the-netxen-nic.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//linux/network/2012/08/16/upgrade-the-netxen-nic.html</guid>
        
        
        <category>linux</category>
        
        <category>network</category>
        
      </item>
    
      <item>
        <title>TCP状态迁移及状态码</title>
        <description>&lt;p&gt;&lt;img src=&quot;/images/post_img/Tcp_state_diagram.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;想必大家对上图都比较熟悉了，补充下内核里对以上状态码的表示，顺便对源代码做了下改动，每个
状态的代码都补出来了。&lt;/p&gt;

&lt;p&gt;```c
tcp_state.h&lt;/p&gt;

&lt;p&gt;enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT    = 2,
	TCP_SYN_RECV    = 3,
	TCP_FIN_WAIT1   = 4,
	TCP_FIN_WAIT2   = 5,
	TCP_TIME_WAIT   = 6
	TCP_CLOSE       = 7, 
	TCP_CLOSE_WAIT  = 8,
	TCP_LAST_ACK    = 9,
	TCP_LISTEN      = 10,
	TCP_CLOSING     = 11,	/* Now a valid state */&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TCP_MAX_STATES	/* Leave at the end! */ }; ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!-- more --&gt;

&lt;p&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;cat /proc/net/tcp&lt;/code&gt;打印时，输出所有active connections，
&lt;a href=&quot;输出格式介绍&quot;&gt;http://search.cpan.org/~salva/Linux-Proc-Net-TCP-0.03/lib/Linux/Proc/Net/TCP.pm#The_/proc/net/tcp_documentation&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;st&lt;/code&gt;这一列即代表连接状态，下面该怎么做，你懂的。&lt;/p&gt;

&lt;p&gt;要想快速高效的显示连接状态信息，推荐用(ss)[http://stackoverflow.com/questions/11763376/difference-between-netstat-and-ss-in-linux]。
Have fun.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Aug 2012 11:39:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//network/c/linux/2012/08/09/check-tcp-connections.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//network/c/linux/2012/08/09/check-tcp-connections.html</guid>
        
        
        <category>network</category>
        
        <category>C</category>
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>how virtualbox work with linux-ck</title>
        <description>&lt;p&gt;解决了virtualbox在linux-ck里使用的问题，做一下记录。我用的是
linux-ck-corex内核，直接通过
&lt;a href=&quot;https://wiki.archlinux.org/index.php/Repo-ck&quot;&gt;repo-ck&lt;/a&gt;装好，不过也可
以通过&lt;a href=&quot;http://aur.archlinux.org/packages.php?ID=50911&quot;&gt;aur&lt;/a&gt;来折腾下，
调整下内核参数啥的。这里主要记录下如何让virtualbox正常工作，&lt;a href=&quot;https://wiki.archlinux.org/index.php/Linux-ck#Running_Virtualbox_with_Linux-ck&quot;&gt;这篇&lt;/a&gt;提到了
一些相关内容，做一点补充:
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&quot;vboxdrv&quot;&gt;编译vboxdrv及其它模块&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;记得装对应的linux-ck-headers，我装的是linux-ck-corex-headers，可能
要先fuck gfw。&lt;/li&gt;
  &lt;li&gt;编译方法有所变化，老版的virtualbox是用&lt;code class=&quot;highlighter-rouge&quot;&gt;vboxbuild&lt;/code&gt;，新版改成了&lt;code class=&quot;highlighter-rouge&quot;&gt;dkms
install vboxhost/4.1.18&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;解决编译vboxdrv报错问题。
    &lt;ul&gt;
      &lt;li&gt;headers安装目录默认是在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/src/kernel_full_name&lt;/code&gt;，在
&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/kernel_full_name&lt;/code&gt;下，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s
/usr/src/kernel_full_name build&lt;/code&gt;，编译应该就ok了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;老版本的virtualbox编译好的modules是存在于&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/extramodules&lt;/code&gt;
下，新的是在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/kernel/misc&lt;/code&gt;下。&lt;/li&gt;
  &lt;li&gt;add/append your user into vboxusers group&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Have fun.&lt;/p&gt;
</description>
        <pubDate>Sun, 29 Jul 2012 18:29:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//linux%20tools%20arch/2012/07/29/virtualbox-work-with-linux-ck.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//linux%20tools%20arch/2012/07/29/virtualbox-work-with-linux-ck.html</guid>
        
        
        <category>linux tools arch</category>
        
      </item>
    
      <item>
        <title>了解lvs调试</title>
        <description>&lt;p&gt;虽然对lvs的实现代码也算是心里有数了，但遇到一些具体问题时还拿不准，这时候就想到了lvs提供的调试功能，
是内核提供的一个选项。一般发行版默认是没打开的，至少我接触的suse enterprice和archlinux都是关闭
了ip_vs_debug，一起来看看怎么启用吧。
kernel config
&lt;code class=&quot;highlighter-rouge&quot;&gt;
CONFIG_IP_VS_DEBUG=y
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在默认的config文件里找到这一项，可能是注释状态，改好后，就可以开始编译内核了，这个选项不是m，必须重新
编译产生新内核，在用&lt;code class=&quot;highlighter-rouge&quot;&gt;mkinitcpio -k kernel_full_name -c config&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;mkinitrd -k kernel_full_name
&lt;/code&gt;，前面是针对archlinux的，后面是针对suse的，这里有坑，此处略去1000字，反正记得如果用新内核启动，出现
找不到root的情况，八成是initrd做得有问题，fs相关的modules的问题。&lt;/p&gt;

&lt;p&gt;新内核一切安好后，就可以玩lvs的调试功能了。先运行下&lt;code class=&quot;highlighter-rouge&quot;&gt;ipvsadm&lt;/code&gt;，再&lt;code class=&quot;highlighter-rouge&quot;&gt;lsmod&lt;/code&gt;看下&lt;code class=&quot;highlighter-rouge&quot;&gt;ip_vs&lt;/code&gt;是否已经加载了。
再后面，就可以检查期待已久的调试选项了
ip_vs debug in /proc 
&lt;code class=&quot;highlighter-rouge&quot;&gt;bash
/proc/sys/net/ipv4/vs/debug_level
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cat debug_level&lt;/code&gt;一下，默认值是0，以后可以通过sysctl来更改默认值，下面讲下这个值的含义:
ip_vs_core.c 
&lt;code class=&quot;highlighter-rouge&quot;&gt;c
 IP_VS_DBG_BUF(1, &quot;Forward ICMP: failed checksum from %s!\n&quot;, IP_VS_DBG_ADDR(af, snet));
&lt;/code&gt;
上面是一个debug macro的调用的例子，下面是宏的具体定义：&lt;/p&gt;

&lt;p&gt;ip_vs.h
&lt;code class=&quot;highlighter-rouge&quot;&gt;c
#ifdef CONFIG_IP_VS_DEBUG
extern int ip_vs_get_debug_level(void);
#define IP_VS_DBG(level, msg...)			\
    do {						\
	    if (level &amp;lt;= ip_vs_get_debug_level())	\
		    printk(KERN_DEBUG &quot;IPVS: &quot; msg);	\
    } while (0)
#define IP_VS_DBG_RL(msg...)				\
    do {						\
	    if (net_ratelimit())			\
		    printk(KERN_DEBUG &quot;IPVS: &quot; msg);	\
    } while (0)
#define IP_VS_DBG_PKT(level, pp, skb, ofs, msg)		\
    do {						\
	    if (level &amp;lt;= ip_vs_get_debug_level())	\
		pp-&amp;gt;debug_packet(pp, skb, ofs, msg);	\
    } while (0)
#define IP_VS_DBG_RL_PKT(level, pp, skb, ofs, msg)	\
    do {						\
	    if (level &amp;lt;= ip_vs_get_debug_level() &amp;amp;&amp;amp;	\
		net_ratelimit())			\
		pp-&amp;gt;debug_packet(pp, skb, ofs, msg);	\
    } while (0)
#else	/* NO DEBUGGING at ALL */
#define IP_VS_DBG(level, msg...)  do {} while (0)
#define IP_VS_DBG_RL(msg...)  do {} while (0)
#define IP_VS_DBG_PKT(level, pp, skb, ofs, msg)		do {} while (0)
#define IP_VS_DBG_RL_PKT(level, pp, skb, ofs, msg)	do {} while (0)
#endif
&lt;/code&gt;
可以清晰的看到，打印debug日志的条件是&lt;code class=&quot;highlighter-rouge&quot;&gt;level &amp;lt;= ip_vs_get_debug_level()&lt;/code&gt;，这个函数调用的返回值就是
&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/net/ipv4/vs/debug_level&lt;/code&gt;，万物皆文件的理念又体现了。
可见level的值越小，其优先级越高，查了一遍ip_vs的相关代码，level最大值不过12，也就是说，
只要把&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/net/ipv4/vs/debug_level&lt;/code&gt;设置成12，就能保证所有ip_vs的日志输出了，但一般没那个必要。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
debug_level to 12 
echo 12 &amp;gt; /proc/sys/net/ipv4/vs/debug_level
&lt;/code&gt;
对了，日志输出是在dmesg。&lt;/p&gt;

&lt;p&gt;好了，方法就差不多是这些了，接下来就边看代码，边测试，边看输出吧。
have fun.&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Jul 2012 21:32:00 +0800</pubDate>
        <link>http://gekben.gitcd.com//linux/network/kernel/2012/07/26/lvs-debug-howto.html</link>
        <guid isPermaLink="true">http://gekben.gitcd.com//linux/network/kernel/2012/07/26/lvs-debug-howto.html</guid>
        
        
        <category>linux</category>
        
        <category>network</category>
        
        <category>kernel</category>
        
      </item>
    
  </channel>
</rss>
